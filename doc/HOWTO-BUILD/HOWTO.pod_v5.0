#  Tstat HOWTO                                        _ _ 
#                                           __________^\^
#\_________________________________________/.:nonsns:.\-/
#
#
# Plain Old Documentation (pod) is not as difficult as it 
# may seem at first sight. If you need some specific help,
# refer to `man perlpod`. Otherwise, here is a short list of
# all you need to know...
# 
# *) pod directives start with =tag
#         remeber to skip >1 line after each directive
#
# *) titles and sections
#            "=headN Title" is as HTML's <HN> Title </HN>
#
# *) lists and items
#           "=over N" starts indentation, "=back" ends it
#           =over 4
#           =item cat
#           =item dog
#           =back
#
# *) bold, etc.
#         bold: B<text> (as \textbf{text} or <B>text</B>)
#         code: C<text> (as \texttt{text})
#         emph: I<text> (as \emph{text})
#         link: L<url>
#
# *) escaping and special characters (can be avoided with C<< )
#           C<$a E<lt>=E<gt> $b> (explicit escaping)
#           C<< $a <=> $b >>     (texttt)
#           Z<< $a <=> $b >>     (normaltext)
#
# *) verbatim paragraphs
#          any section that begins
#
#

=pod



=begin latex


       %palatino
       \fontfamily{ppl}\selectfont


=end latex



=head1 Installation 


This document provides basic information
for the installation, configuration and usage 
of Tstat and its optional add-ons.



=head2 Requirements



=head3 Operating System



Tstat has been tested tested on C<Linux 2.2.x>, C<2.4.x> and C<2.6.x> kernels, 
using C<RedHat 6.x-9.x>, and C<Fedora Core x> systems. 
It should work under other C<UNIX> dialects, such as 
C<FreeBSD>, C<NetBSD 1.3> and C<MAC OS X> (although we do not have either of 
those platforms for testing purposes). If you are able to run Tstat on 
other OSs, we well be happy to include them in the list.


=head3 System Libraries


Tstat requires, by itself, a few library that should
already be installed on your system, such as 
C<libpcap> (available from L<http://www.tcpdump.org>) 
or the DAG drivers (available from L<http://www.endace.com>), 
in case you use such hardware. With these libraries, 
you are ready to capture and process the traffic flowing
in your LAN.

Since Tstat uses pthread to improve the performance in case of real time
analysis, your system must support POSIX thread as well.

Finally, to use the RRD functionalities, you also need to have a working
installation of the RRDtool (available from
L<http://people.ee.ethz.ch/~oetiker/webtools/rrdtool/>).



=head3 Post-Processing


Some of the additional plotting capabilities, such
as the ones used in Tstat old web interface at
L<http://tstat.tlc.polito.it/tstat.old/main.php>, requires
Perl 5.x and some modules to be installed on your system. 
Both Perl and the required modules (namely, C<Date::Manip>
and C<Compress::Zlib>) are available from L<http://www.cpan.org>.
With these tools, you are ready to perform additional 
post-processing  and visualize the collected dataset.



=head3 Round-Robin Database


Finally, weather you plan to use the Round-Robin Database
capabilities featured by Tstat, then you need to install
C<RRDtool> on your system (available from
L<http://people.ee.ethz.ch/~oetiker/webtools/rrdtool/>).
Although Tstat works
with I<any> version of RRDtool (we have successfully tried 
with 1.0.x and 1.2.x), you may want to download its latest 
version. With RRDtool, you are ready for extremely-scalable 
traffic monitoring and analysis.





=head2 Installation Instructions


Download and uncompress the tarball. Assuming
that you want to download version C<1.x>, this can be done with:

         wget http://tstat.tlc.polito.it/download/tstat-1.01.tar.gz
         tar xzvf tstat-1.x.tgz
         cd tstat/


Check the C<Makefile.in> (I<double check it!> ;-)), choosing the correct options
you like  based on your system configurations. The changes are very simple, such
as adding or removing supported input file formats and compression tools,
toggling support for DAG (default C<off>), and RRDtool (default C<off>). All the
compile time options are managed via C<#define> directives.  Now, run:


        ./configure 


to generate a suitable C<Makefile>. Then run:


         make


to produce an executable file named C<tstat>.

# For instructions
#related to the Round Robin Database module installation and
#configuration, please refer to the L<appropriate section|"RRD Module">
#on this document.







=head1 Usage



There are few things to know to run Tstat: first, you are required to have a
knowledge  of the network that you want to monitor. 
Second, there are the few options that are described in this section.


=head2 Synopsis


Tstat primary usage is as a command-line tool; the synopsis of 
the command is the following:


       Usage:
               tstat [-hHtuvwp] [-d[-d]] [-Nfile] [-sdir]
        	     [-rRRD_out_dir] [-Rrrd_conf] [-S]
        	     [-l] [-iinterface]
        	     [-ffilterfile] <file1 file2>

       Options:
               -h: print this help and exit
               -H: print internal histograms names and definitions
               -t: print ticks showing the trace analysis progress
               -u: do not trace UDP packets
               -v: print version and exit
               -w: print [lots] of warning
               -p: enable multi-threaded engine (useful for live capture)

               -d: increase debug level (repeat to increase debug level)
               -Nfile: specify the file name which contains the
                       description of the internal networks.
                       This file must contain the subnets that will be
                       considered as 'internal' during the analysis
                       Each subnet must be specified using network IP address
                       on the first line and NETMASK on the next line:
                       130.192.0.0
                       255.255.0.0
                       193.204.134.0
                       255.255.255.0

               -sdir: puts the trace analysis results into directory
        	      tree dir (otherwise will be <file>.out)
               -S: pure RRD-engine: do not create histograms and log_* files
               -Rconf: specify the configuration file for integration with
        	     RRDtool. See README.RRDtool for further information
               -rpath: path to use to create/update the RRDtool database
               -Dconf: DPMI configuration file
               -l: enable live capture using libpcap
               -iinterface: specifies the interface to be used to capture traffic
               -ffiterfile: specifies the libpcap filter file. Syntax as in tcpdump

               file: trace file to be analyzed
        	     Use 'stdin' to read from standard input.

       Note:
               When tstat is called with no arguments (on the command line),
               it will first check if a file <tstat.conf> is provided in the
               same directory where the execution started.
               In the latter case, arguments will be read from <tstat.conf>
               rather than from the command line

       Supported Input File Formats:
               tcpdump          tcpdump format -- Public domain program from LBL
               snoop            Sun Snoop format -- Distributed with Solaris
               etherpeek        etherpeek format -- Mac sniffer program
               netmetrix        Net Metrix format -- Commercial program from HP
               ns               ns format - Network simulator ns2 from LBL
               netscout         NetScout Manager format
               erf              Endace Extensible Record format
               DPMI             Distributed Passive Measurement Interface (DPMI) format
               tcpdump live     Live capture using pcap/tcpdump library




=head2 Live Capture


Tstat can sniff and analyze traffic on-line through the
use of either the C<libpcap> library or Endace DAG cards. Recently
also, Tstat has been integrated with the Distributed Passive 
Measurement Interface (DPMI) library.

The usage of Tstat is very easy, especially if you have
experiences with C<tcpdump>, although C<tcpdump>'s knowledge
is not required to profitably use Tstat. Moreover, advanced 
users will enjoy the ability of on-line processing of traffic
captured with DAG cards or the DPMI infrastructure (see below
in this document).



=head3 A Simple Example


As a minimal configuration, you must describe your network to Tstat. Indeed, in
order to distinguish forward and backward paths, Tstat needs  to know which host
IP addresses can be considered as ``internal'' to the monitored network. In our
case, Politecnico di Torino internal addresses are C<130.192.0.0/16> and
C<193.204.134.0/24>, so the network description C<net.conf> looks as  following:


         bash> cat net.conf
         130.192.0.0
         255.255.0.0
         193.204.134.0
         255.255.255.0


We can now run Tstat to capture the traffic flowing across the edge
of our network, with the following command, which must be run as C<root> (as you
need to capture packets by putting the Ethernet interface in promiscuous mode).
The simplest command is the following, whose output will
be described L<later|"Output">


         ./tstat -l -Nnet.conf


=head3 More Control

                
We can control the interface that we want to sniff as well as
the output directory name as follows:


         ./tstat -ieth1 -l -stest -Nnet.conf


Moreover, we can also pipe Tstat input using the special keyword
C<stdin> as input, as in the following command (piping ns2 output to 
Tstat is left as an exercise for the reader):


         tcpdump -s 80 -i eth0 -w - ip | ./tstat -Nnet.conf -spiped stdin


In this case, Tstat is fed by C<tcpdump>'s output, and the latter has been
instructed to capture packets on the eth0 device, collecting the
first 80 bytes (to track uniquely of packet headers) of IP packets only, 
and send the output to C<stdout>. Moreover, since Tstat understands 
the C<libpcap> syntax, filters can be stored in text files, as in 
the following command sequence:


         echo "vlan and ip and host 10.0.0.1" > tcpdump.conf
         ./tstat  -ieth0 -l -ftcpdump.conf -Nnet.conf -sfiltered


Finally, although more informations on the RRD module configurations will
be given in section L<RRD|"RRD Module">, here we briefly illustrate
the I<calling syntax> involving RRD. 
If Tstat has been compiled with the RRD module, then it will
be possible to create an RRD database, additionally to the
aforementioned Tstat analysis, with the following command:


         ./tstat -ieth1 -l -stest -Nnet.conf -Rrrd.conf -rlocal_dir


where C<local_dir> is the output directory where the RRD database
will be stored and C<rrd.conf> tells Tstat which variables should
be added to the RRD database.
Note that, whether you plan a longer monitoring, then the output produce by
Tstat (C<log_*> and the periodical histogram dump) can pose serious scalability
problems. In this case, Tstat can be run as a pure RRD engine as in the
following example, where the RRD output directory has been carefully chosen in
order to be accessible from the Web server running the C<tstat_rrd.cgi>:


         ./tstat -l -S -Nnet.conf -Rrrd.conf -r/var/www/cgi-bin/rrd_data



=head2 Trace Analysis


Beside live-capture, it is possible to run Tstat on a previously collected 
trace file, where the trace format can be any of the following:

	Supported Input File Formats:
        tcpdump          tcpdump -- Public domain program from LBL
        snoop            Sun Snoop -- Distributed with Solaris
        etherpeek        etherpeek -- Mac sniffer program
        netmetrix        Net Metrix -- Commercial program from HP
        ns               ns -- network simulator from LBL
        netscout         NetScout Manager format
        erf              Endace Extensible Record Format
        DPMI             Distributed Passive Measurement Interface (DPMI) format
         

Tstat will try to read trace files given as input, and to automatically identify
the correct dump format. Trace files can be compressed or uncompressed, and
Tstat will automatically detect the compression tool used (supported formats are
C<compress, gzip, bzip2>).

Without loss of generality, we assume to use the first of the above formats. The
calling syntax is similar to the previous one, with the exception of the absence
of the live-capture switch C<-l> and the presence of the name(s) of the file(s)
that have to be processed. For example, the following command can be used to
analyze a trace file named C<23_00_28_Jun_2000.dump.gz>. Results of the analysis
will be stored in a subdirectory named C<trace1>; as before, C<net.conf> contains  the
subnet description that  will be  considered as ``internal'' during the
analysis.


         ./tstat -strace1 -Nnet.conf 23_00_28_Jun_2000.dump.gz



=head1 Output


=head2 Output Classification 


Recall that Tstat assumes that traces are collected on a bidirectional link,
such that both data and control packets belonging to the same flow are observed;
with the help of the figures below, we will explain the different classification
of measurements used by Tstat.


=begin text


                                       out
                  +---------------------+    
                  | +-----------------+ |
                  | | +-+          in | |
         	  | | | | loc	      | |
         	  v | v v	      v |
         	    
         	 internal           external  
         	 addresses	    addresses
         	 

         	 
           				s2c
                  +---------------------+    
                  | +-----------------+ |
                  | | c2s             | |
         	  | |   	      | |
         	  v |   	      v |
       
                 client		    server 


=end text





=begin html


         <center><img src="/HOWTO/tstat_output.png"></img></center>


=end html



=begin latex



         \begin{figure}[!htb]
             \begin{center}
                 \includegraphics[width=0.6\textwidth]{tstat_output.eps}
             \end{center}
         \end{figure}



=end latex




Tstat identifies hosts based on its IP address. Given the description
of the internal hosts through the C<-N> command line option, Tstat
distinguishes among I<incoming>, I<outgoing> and I<local> 
measurements. Packets whose destination is an internal host and whose source is
an external host will contribute to I<incoming> measurements (red arrow in the
top figure), whereas packets going
in the opposite direction will contribute to I<outgoing> measurements (green
arrow in the top figure). Finally, in
some cases it is possible that Tstat observes packets whose source and
destination hosts belongs to the internal host set: in such cases, measurements
will be classified as I<local> (blue arrow in the top figure).
Notice that packets whose source and destination IP
addresses belong to the external host set will be discarded.
For example, consider a setup in which Tstat is attached to a snoop port of a
LAN switch. Then Tstat will be fed by i) I<outgoing> packets going to the default gateway,
ii) I<incoming>   packets coming from the default gateway,
iii) I<local> packets.

Note that if you either do not know or do not want to distinguish between
internal, external and local hosts, you may enable the C<-DLOG_UNKNOWN>
directive when compiling Tstat. Tstat will then be less strict, but results may
be difficult to be correctly interpreted.



Considering instead the I<role> of the host that sent the packet,  statistic are
collected distinguishing between I<clients> (green arrow in the bottom figure)
and I<servers> (red arrow in the top figure), i.e., host
that opens a connection and and host that replies to connection request. Recall
that while TCP connections are well defined, UDP (and RTP/RTCP) connection
definition is more fuzzy. In this latter case, Tstat will consider as client the
source IP address of the host that sent the first packet of that flow, while the
server will be the host identified by the destination IP address of the same
packet.




Therefore, when applicable, Tstat will keep track of measurement referring to
the same measured quantity by I<appending> a specific tag  to the filename:

=over 4

=item C<_out>

outgoing: from an internal host to an external host

=item C<_in> 

incoming: from an external host to an internal host

=item C<_loc>

local between two internal hosts 

=item C<_c2s>

going from the Client to the Server

=item C<_s2c>

going from the Server to the Client


=back



=head2 Output Structure



Tstat collects several network-layer as well as transport-layer measurements,
which are described in full details in
L<http://tstat.tlc.polito.it/measure.shtml>. As output, Tstat produces three
different types of measurement collections, which will be described in the
current section:



=over 4

=item Histograms 

storing the I<distribution> of a given quantity during a time interval.

=item Round Robin Database 

stores a configurable subset of the same quantities through the RRD interface.

=item Log files 

storing a complete transport-layer I<log> of all the parameters measured.

=back




=head2 Output Types


This section details the different I<types> of measurement collections
generated by Tstat; for detailed informations on  the specific I<metrics> 
that Tstat is able to gather, please refer to  the Tstat website 
L<http://tstat.tlc.polito.it/measure.shtml>.


=head3 Histograms


=for html <a name="histo"></a>


Histograms are generated periodically: Tstat collects all the
measurement data during a given measurement interval defined by the C<MAX_TIME_STEP> 
parameter, which is hard-coded in the C<param.h> file to 5 minutes. Please, note
that changing the C<MAX_TIME_STEP> parameter may affect RRD creation as well.
For examples, considering the IP packet length, Tstat updates, for
each observed IP packet, the counter of the number of observed packets with a
particular length. At the end of the measurement period, Tstat then saves
the values stored in the histogram, resets all the values, and then restarts 
the samples collection.

Considering the last example of previous section, we let:


         ./tstat -strace1 -Nnet.conf 23_00_28_Jun_2000.dump.gz


running for some time. The output generated by tstat consists of a directory 
tree like the following:


        trace1
	`-- 08_10_13_Apr_2000.out
	    |-- 000
	    |   |-- addresses
	    |   |-- flow_number
	    |   |-- ip_len_in
	    |	...
	    |   |-- udp_port_flow_dst
	    |   `-- udp_tot_time
	    |-- 001
	    |   |-- addresses
	    |   |-- flow_number
	    |   |-- ip_len_in
	    |	...
	    |   |-- udp_port_flow_dst
	    |   `-- udp_tot_time
	    ...
	    |-- LAST
	    |   |-- addresses
	    |   |-- flow_number
	    |   |-- ip_len_in
	    |	...
	    |   |-- udp_port_flow_dst
	    |   `-- udp_tot_time
	    |-- log_rtp_complete
	    |-- log_tcp_complete
	    `-- log_tcp_nocomplete
		


=over 4

=item * Main database

The topmost directory is created according to the command line  option C<-s>,
which in this case is set to  C<trace1>. This is intended to be the main database
directory. 

=item * Trace Start Time

A subdirectory named from the timestamp of the first tracked packet is created using
the C<"%H_%M_%d_%b_%Y.out"> (or, in a more  human readable format, 
C<hour_minute_day_Month_year.out/>) notation. When running in live mode (-l
option), a new directory with the name of the current tracked packet Timestamp
will be created every C<DIRS*MAX_TIME_STEP> time. The parameter C<DIRS> is
defined in the file C<param.h> as well. By default it is set to 12, so that a
new dir will be approximatively created every hour of live measurement.

=item * Collection Interval

Subdirectories with increasing numbers will be created for each measurement
period with the format C<nnn/>; histograms collecting measurement results will
be created in these directories; note that the histograms referring to the last
I<partial> time period will be stored in the LAST subdirectory.

=item * Histogram data

Each of these C<nnn/>  directories contain several histograms, one for each of 
the measured parameters,  relative to the nnn-th C<MAX_TIME_STEP> long time interval;
notice that the tags C<_in>, C<_out>, C<_loc>, C<_c2s> and C<_s2c>
are appended to indicate the classification of the observed stream.

Histogram data are saved using simple ASCII files.
The format is simple: the first line contains a description of the
measured quantity, while the second line contains the parameters of the histograms
(minimum and maximum values, and size of each bins). The list of all
the counter index and values is then dumped. To limit the file size, the
corresponding entry is omitted if the counter is zero.
For example, the histogram of the packet length C<ip_len_in> looks like:

     #IP packet length - incoming packets
     #min=0 bin_size=4 max=1600
     28 7
     36 277
     40 11760
     44 3463
     ...

=back

Simple L<Post Processing> tools are available to automatically manage the histogram
database.



=head3 RRD


=for html <a name="rrd"></a>


The RRD output consists of a series of binary files stored in the RRD format.
Tstat forces a particular I<naming notation> of such files, which follows
the configuration rules described later on the L<RRD section|"RRD Configuration">.

The RRD can then be queried with the standard RRDtool commands, such as
C<rrdcreate>, C< rrdupdate>,  C< rrdgraph>, C< rrddump>, C< rrdfetch>, 
C< rrdtune>, C< rrdlast>, C< rrdxport>, to whose manual pages we refer 
the reader for further informations.


=head3 Logs 


=for html <a name="logs"></a>


Tstat creates three transport-layer log-files: C<log_tcp_complete>,
C<log_tcp_nocomplete> and C<log_rtp_complete>. 
Log files are placed in the main database directory.

TCP flows can be either completed or not depending whether Tstat observed the
3-way handshaking or not; in the first case, all the measured indexes relatively
to each flow will be collected in the C<log_tcp_complete>; in the latter
case,  flows are considered as garbage and stored in C<log_tcp_nocomplete>;
Description of the file format of the TCP log files can be found in
L<http://tstat.tlc.polito.it/measure.shtml>.

Similarly, a complete log keeping track of each RTP flow measured indexes is
maintained in the  C<log_rtp_complete> file. Being RTP basically a
connectionless protocol, it is impossible to distinguish among C<complete> and
C<nocomplete> flows in this case.


=head2 Post Processing


This section could be a separate HOWTO, since this
argument cannot be treated exhaustively. Perl, Awk, Ruby
I<Your-Favorite-Scripting-Language> scripts are definitively
best candidates to post-process C<log_*> files.

In the Tstat download page, you
can find C<plot_time.pl> and C<plot_cum.pl>, two Perl scripts that may be useful
to produce either i) time or ii) aggregated plots over different time spans.
They directly access to the histogram database create by Tstat.
Please, refer to L<http://tstat.tlc.polito.it/software.php#postprocess>.

RRD files can be manipulated to obtain I<indirect> 
metrics through the RPN manipulations mechanism provided 
by RRDtool. 


=head2 Storage Considerations


To give the user a rough idea of the size of the output,
let consider the 6 hours long, 1.6GB packet-level trace containing 
21M packets, sniffed with C<tcpdump> that was used throughout this tutorial.
Tstat identified and analyzed about 729K flows, of which about 495K were 
TCP flows, trashing 20K of them into C<log_nocomplete>.
Referring to the L<output structure |"Output Structure"> above shown,
we can express the following observations:  


=over 4

=item Histogram

As previously described, in order to take into account the flow directions, 
several histograms are dumped for the same variable C<var_{in,out,loc,c2s,s2c}>.
Currently, about 60 measurement indexes, described in 
L<http://tstat.tlc.polito.it/measure.shtml>,  are logged, for a total
of 180 files. Each of the C<000/>, C<001/> ... C<LAST/> directories is about
500KB-1MB depending on the network traffic and on the file system block
allocation mechanism.

Therefore,  as a rule of thumb, you can count about 1MB of storage due to
histograms every 5 minutes of traffic (independently of the amount of actual
traffic load during the 5 mins...). This can be useful in order to set the
periodic dump timer to the desired trade off among time granularity versus
storage size  required.


=item RRD

The C<rrd/> directory is, per construction, of fixed size: this should not be a
surprise, since this is the goal of RRD. Therefore, the size of the database
does not depend on the amount of network traffic processed, but rather on the
RRD configuration. For the standard configuration supplied with Tstat, which is
also the one used in our Web server, the whole database occupy only 6MB and
consists of about 250 files.

=item Logs

The total size of the log files amount to about 200MB, which 
gives  a 8x reduction factor w.r.t. the packet-level trace; or,
the storage cost of each flow is about 400 bytes.

Note that the C<log_*> can be further compressed, using C<gzip>
to less than 50MB, which gives a further 4x size gain; 
however, for a matter of performance, is preferable 
to compress the log files I<offline>.


=back


Finally, consider that on a common PC architecture (specifically,
Intel P4 2.40GHz equipped with 2GB of RAM and 7200rpm hard-disk),
the whole trace elaboration took only 4 minutes; thus, the 
analysis rate is roughly 85Kpkts/sec or 3Kflows/sec.


=head1 RRD Module



=head2 RRDtool Installation


In order to get Tstat RRD module working, you will need to install RRDtool first
(refer to the homepage of RRDtool 
L<http://people.ee.ethz.ch/~oetiker/webtools/rrdtool>  to accomplish this step).
Then, make sure to specify that you want native RRD support in Tstat by
modifying the C<Makefile> accordingly, and (re)compile Tstat: you will have to
uncomment the following lines in C<Makefile>, and  to double-check
that the RRDtool version and path  are coherent with your system settings.


   DEFINES    += -DHAVE_RRDTOOL
   RRD_VER     = 1.2.9
   RRD_LDLIBS  = -lrrd
   RRD_LDFLAGS = -L/usr/lib/ -L/usr/rrdtool/lib/  -L/usr/rrdtool-${RRD_VER}/lib/
   RRD_INCS    = -I/usr/rrdtool/include/ -I/usr/rrdtool-${RRD_VER}/include

If someone is willing to integrate the RRD identification and configuration
directly via the C<configure>, we will appreciate it!


=head2 RRD Configuration


Tstat RRD configuration is very easy, being centralized
in a single text-file, which allow to specify at the runtime what measurements
should be monitored. The operating frequencies
for the RRD sampling (i.e., the parameters for the temporal 
averages) are hard-coded into C<rrdtool.h> and are chosen to 
mimic MRTG behavior. Again, take care that modifying the C<MAX_TIME_STEP>
parameter may affect the RRD management as well.

The RRD configuration file, specified through the command line option C<-R>,
should contain one line for each of the Tstat parameters that have 
to be integrated into a Round Robin Database. Each line allows to 
specify which statistical properties of the variable has to be tracked,
as follows:


          tstat_var1 avg min max stdev var val:a,b,c,d idx:e,f,g,h,other prc:i,j,k


where C<avg,min,max,stdev,var,idx,prc,other> are keywords, whereas C<a,b,c,d,i,j,k> 
are floating point numbers and C<e,f,g,h> integer values; note that
the list of indexes (e.g., TCP ports), values (e.g., packet size)
and percentiles are comma separated. The name of the variables are
Tstat internal ones: they can be shown by executing C<./tstat -H>,
Alternatively, you can directly look into the C<000/> ...  C<LAST/>  directories or
or at L<http://tstat.tlc.polito.it/measure.shtml>. 

Valid configuration lines are, e.g.:

          #
          # inspect IP packet length average, specific values and distribution
          #
          ip_len_in   avg prc:50,90,95,99 idx:40,1500,other

          #
          # TCP well known ports       
          #                       
          # 20    FTP-DATA             
          # 21    FTP                  
          # 22    SSH                  
          # 23    telnet               
          # 25    SMTP                 
          # 80    HTTP                 
          # ...                        
          #
          tcp_port_dst_in       idx:20,21,22,23,25,80,other          

          #
          # good approximation of the distribution of the RTT,
          # taking into account only the incoming path contribution
          #
          tcp_rtt_avg_in  prc:0.1,1,5,10,25,50,75,90,95,99,99.9


where, evidently, the lines starting with a C<#> sign are treated as comments.
Our Web server is currently running with the configuration
available at L<http://tstat.tlc.polito.it/download/rrd.conf>.

For each specified quantity defined in the rrd.conf file, a corresponding file
will be created.
For example, consider that the generic configuration line:


          tstat_var avg min max stdev var val:a,b,c,d idx:e,f,g,h,other prc:i,j,k


will produce the following files (17 in total):


          tstat_var.{avg,min,max,stdev,var}.rrd
          tstat_var.val{a,b,c,d}.rrd
          tstat_var.idx{e,f,g,h,oth}.rrd
          tstat_var.prc{i,j,k}.rrd


=head2 Tstat RRD and the Web 


From the Tstat web site, you can
download the most up-to-date version of C<tstat_rrd.cgi>,
which is the CGI script that renders the Web interface.
Here is some basic tips to get it working; if you wonder
how to write your own graph templates, then you are probably
skilled enough to get it on your own C<:)>


=head3 Database Structure


The CGI scripts allow to browse on the fly the RRD database structure.
The C<rrd_data> directory is the root of the tree, where each
directory contains either i) other directories (i.e., is a box) 
or ii) a RRD-database, in which case the node is a leaf and will be 
shown in the interface. In case that a directory is a plain box, it may
optionally contain some files (specifically 
{C<HEADER>,C<FOOTER>,C<README>}.{C<html>,C<txt>})
that will be rendered by C<tstat_rrd.cgi>. 
By default, the cgi script tries to load the html version;
otherwise, it tries to displays "<pre> `cat FILE` </pre>"
if such a FILE exists; finally, it will display a default message
held in $default{README} hard coded in the script.

Here is an example of the rrd_data directory which hold part of the RDD database
accessible from the tstat web page.


        rrd_data/
         |-- Example
         |-- GARR
         |   |-- garr-live
         |   `-- garr-old
         `-- Polito
             |-- 2000
             |   |-- Apr
             |   |-- Jun
             |   |-- Jun,post155
             |   `-- May
             |-- 2001
             |   |-- Feb
             |   `-- Jan
             |-- 2005
             |   |-- Apr
             |   `-- Feb
             `-- Current
         


        



=head3 Web Configuration


The web configuration really depends on your web server configuration. Few
dependencies are required, most notably, the RRD Perl library from the RRDtool
installation.

It is advisable to store the Tstat RRD files
everywhere you want, and then create a symbolic link 
named C<rrd_data> that points to it (i.e., to the root of 
the rrd database tree). Similarly for the directory
where the rendered images should be stored (defaults to C<cgi-bin/rrd_images>)
and can be a symbolic link as well.
The names of these symbolic links can be redefined in the 
configuration section of C<tstat_rrd.cgi> if needed:


        #   ____________________________
        #  /                            \
        # /    configuration  __________/
        # \__________________/.:nonsns:.
        #
        # specify path to the root of the rrd database tree
        # by default, I assume there is a symbolic link in cgi-bin/
        # named rrd_data
        $RRD_DATA = 'rrd_data';

        # same thing for image directory
        # in my case, var/www/cgi-bin/rrd_images is
        # a symbolic link to "/var/www/html/rrd_images";
        # from the html browser's perspective
        $IMG_DIR = "rrd_images";


=head1 DPMI Module


To the experienced DPMI user, it can turn very useful to
think of Tstat in terms of a DPMI consumer, thus suitable
for live usage. Basically, two configuration files need to 
be provided in case.


=head2 Tstat Configuration for DPMI

Especially to
this purpose,  Tstat can be executed without any argument
on the command line, provided that a file named C<tstat.conf> 
exists in the same path where the C<tstat> command has been
executed. Note that filename MUST be in this case C<tstat.conf> 


In the latter case, arguments will be read from 
C<tstat.conf> rather than from the command line, which makes
Web-based execution easier -- it just require the creation of
a text file.

Typically, the content of the file will one of the two following
cases. When only the RRD module need to be turned on, which is 
specially suitable for the persistent monitoring of a network link:

	  -Ddpmi.conf -S -Rrrd.conf -rdata.rrd

Or, in the case where more detailed transport layer logs and histograms 
to be generated, such as for shorter ad-hoc experiment:

	  -Ddpmi.conf -sdata

Note that the C<dpmi.conf>  filename, which is the object of the next 
section, is customizable.


=head2 DPMI Configuration for Tstat


This file is used by Tstat in order to properly set-up the 
DPMI library and, possibly, its filters. There are only two
keywords that are interpreted by Tstat, and I<the whole> 
content of this file is passed to the DPMI's C<createfiler>
library call.
Tstat-keywords are prepended by the C<tstat:> prefix, to 
solve any ambiguity, and are related to the type of stream
and measurement direction.
More specifically, 

=over 4


=item C<tstat:(file|(tcp|udp|eth)[:port])>


Specify whether a tracefile or a network socket (and in this case, on which port)
is the source of DPMI traffic. Note that in the case where a tracefile
is used, there is no real need to specify this, since the format recognition
happens automatically; thus, the C<tstat:file> keyword is provided for completeness.
Conversely, options such as C<tstat:eth> and C<tstat:tcp:32449> are
necessary in order for network sokets to properly be setup.


=item C<tstat:MP:CI>


This option is used to define the traffic directionality, specifing 
what network card interface (CI) and the measurement point (MP) 
are related to I<incoming> traffic from external sources.
Referring to the DPMI library internals:
      
      CI <-> char nic[8];     
      MP <-> char mampid[8];  

=back


In order to provide a safe failback or missing configuration,
unless otherwise specified, the first received frame is assumed to 
be ``incoming'', thus arbitrarily determinining the incoming CI:MP 
couple.


=head1 Author Informations



Marco Mellia, Assistant Professor.
<marco.mellia@polito.it>



Dario Rossi, PostDoc Researcher.
<dario.rossi@polito.it>



Telecommunication Networks Group (TNG)
DELEN, Politecnico di Torino

=head1 Acknowledgment

Many people contributed to the development of Tstat. Tstat would never have seen
the light had not C<TCPTrace> being invented.
Many thanks to Shawn Ostermann and to the  Ohio
University for their great program.

Many Master and PhD students took part in the development and debugging of
Tstat. Naming all of them would be impossible. We would then like to thank Luca
Muscariello for the entropy generated in the TCP
anomalies identification, and Prof. Fabio Neri who gave us the
moral and scientific support to continue investing in Tstat. 





=head1 License



Copyright (c) 2001 Politecnico di Torino.  All rights reserved.

 
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.


=cut
