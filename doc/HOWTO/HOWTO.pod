#  Tstat HOWTO                                        _ _ 
#                                           __________^\^
#\_________________________________________/.:nonsns:.\-/
#
#
# Plain Old Documentation (pod) is not as difficult as it 
# may seem at first sight. If you need some specific help,
# refer to `man perlpod`. Otherwise, here is a short list of
# all you need to know...
# 
# *) pod directives start with =tag
#         remember to skip >1 line after each directive
#
# *) titles and sections
#            "=headN Title" is as HTML's <HN> Title </HN>
#
# *) lists and items
#           "=over N" starts indentation, "=back" ends it
#           =over 4
#           =item cat
#           =item dog
#           =back
#
# *) bold, etc.
#         bold: B<text> (as \textbf{text} or <B>text</B>)
#         code: C<text> (as \texttt{text})
#         emph: I<text> (as \emph{text})
#         link: L<url>
#
# *) escaping and special characters (can be avoided with C<< )
#           C<$a E<lt>=E<gt> $b> (explicit escaping)
#           C<< $a <=> $b >>     (texttt)
#           Z<< $a <=> $b >>     (normaltext)
#
# *) verbatim paragraphs
#          any section that begins

=pod



=begin latex


       %palatino
       \fontfamily{ppl}\selectfont


=end latex


=head1 Installation 


This document provides basic information
for the installation, configuration and usage 
of Tstat and the Bayesian framework for Skype
traffic identification.  A more general
description of the program as well as other
documentation can be found in the Tstat homepage
L<http://tstat.tlc.polito.it> 



=head2 Requirements



=head3 Operating System



Tstat has been tested tested on C<Linux 2.2.x>, C<2.4.x> and C<2.6.x> kernels, 
using C<RedHat 6.x-9.x>, and C<Fedora Core x> systems. 
It should work under other C<UNIX> dialects, such as 
C<FreeBSD>, C<NetBSD 1.3> and C<MAC OS X> (although we do not have any of 
those platforms for testing purposes). If you able to run Tstat on other OSs, we
will be happy to include them in the list. 

=head3 System Libraries


Tstat requires, by itself, a few library that should
already be installed on your system, such as 
C<libpcap> (available from L<http://www.tcpdump.org>) 
and the DAG drivers (available from L<http://www.endace.com>), 
in case you use such hardware. With these libraries, 
you are ready to capture and process the traffic flowing
in your LAN.

Since Tstat uses pthread to improve the performance in case of real time
analysis, your system must support POSIX threads as well if you want to
profit of this feature. However, keep in mind that threaded execution 
is only an optional feature, and is necessary only for online traffic
analysis, so that this is not a strict requirement: for this reason,
threading is disabled by default.

Finally, to use the RRD functionalities, you also need to have a working
installation of RRDtool (available from L<http://oss.oetiker.ch/rrdtool/>).


=head2 Quick Install

Assuming that you want version C<2.x.y>:

	 wget http://tstat.polito.it/download/tstat-2.x.y.tar.gz
         tar -xzvf tstat-2.x.y.tar.gz
         cd tstat-2.x.y
         ./autogen.sh
         ./configure [--enable-libtstat]
         make
         make install (with root privileges)

This commands install a executable file named C<tstat> in C</usr/local/bin>.

=head2 Complete control of Building

The most important elements in the Tstat's package are:

    tstat/
    tstat-conf/
    libtstat/
    include/
    libtstat-demo/
    doc/ 
    doc/HOWTO
    README AUTHORS NEWS INSTALL ChangeLog
      

The C<tstat> directory contains the source code of Tstat which
is also the default building target. Beside Tstat it can also be compiled
the C<Libtstat>, a shared library which allows to an external program to access 
to the traffic analysis functions of Tstat. In the C<include> directory there is the
header file of the library instead in the C<libtstat-demo> directory there is a simple 
program of example that shows how to use the Libtstat 
(see L<Libtstat library> for more information about the Libtstat API).

The building of the Libtstat library is disabled by default but is provided
a configuration option to control this feature

    ./configure --enable-libtstat    # build tstat, libtstat and libtstat-demo
    ./configure                      # build only tstat

At the end of C<configure> is printed a small report:

    -------------------------------------------------
      tstat Version 2.2
      -lpcap -lpthread -lm  -lrrd -lz

      Prefix: '/usr/local'

      Package features:
    	- pcap      yes
    	- zlib      yes
    	- rrd	    yes
    	- libtstat  no
    -------------------------------------------------

This indicate if the libtstat has been selected or not for the building 
and if either C<Librrd> or C<Zlib> were found in the system, 
in which case they are automatically added in building the project.

Tstat's source code uses some preprocess definition to enable/disable some features,
like for example the DAG support which is disabled by default.
These definitions are declared in the C<tstat/Makefile.conf> each with a specific 
description about its purpose so it should be easy change to behaviour in the building
process commenting/uncommenting some lines.

=over 1

=item

NB: remember to run C<autoreconf> from the root of the package every time 
a change in these file is performed!!!

=back

The building of Libtstat is separated from the building of Tstat so C<libtstat/Makefile.conf>
file defines the set of option specific for the Libtstat, while C<tstat/Makefile.conf>
is specific for Tstat.

In the directory C<tstat-conf> there are some examples of configuration files 
needed by Tstat; for example the set of local addresses (-N option), 
the configuration of the histograms (-H), RRD tool (-R), runtime (-T) and 
bayesian framework (-B).

In the directory C<doc> there are some plain text files that describes the format
of logs files generated by the analysis and in C<doc/HOWTO> there is howto document 
in different file formats.
C<README>, C<AUTHORS>, C<INSTALL>, C<NEWS> and C<ChangeLog> instead are plain files that
describes some general information about the package like the authors, the last new
features of the tools, etc...

=head2 Complete control of Installation

The default C<prefix> for installation is C</usr/local> so
Tstat executable in installed in C</usr/local/bin> and Libtstat 
is installed in C</usr/local/lib>. Anyway a different C<prefix> can
be specified at configuration time

    ./configure --prefix=/absolute/path/where/install/tstat

Libtstat-demo is only a demonstration tool so is build only a local
executable that is not installed. 

Libtstat is provided with C<pkg-config> support so a C<libtstat.pc> is installed in
C</usr/lib/pkg-config> and typing

    pkg-config --cflags --libs libtstat

it should appears an output like

    -I/usr/local/include  -L/usr/local/lib -lm -lpthread -lpcap -lrrd  

that indicates the C<CFLAGS> and C<LIBS> options used in the building
process.

=head1 Usage


There are few things to know to run Tstat: first, you are required to have a
knowledge of the network that you want to monitor. 
Second, there are the few options that are described in this section.


=head2 Synopsis


Tstat primary usage is as a command-line tool; the synopsis of 
the command is the following:

    Usage:
        tstat [-htuvwpgSL] [-d[-d]]
              [-s dir]
              [-N file]
              [-C file]
              [-B bayes.conf]
              [-T runtime.conf]
              [-z file]
              [-H ?|file ]
              [-Z] [-P]
              [-r RRD_out_dir] [-R rrd_conf]
              [-l] [-i interface] [-E snaplen]
              [-f filterfile]
              <file1 file2>

    Options:
        -h: print this help and exit
        -t: print ticks showing the trace analysis progress
        -u: do not trace UDP packets
        -v: print version and exit
        -w: print [lots] of warning
        -c: concatenate the finput files
            (input files should already be in the correct order)
        -p: enable multi-threaded engine (useful for live capture)
        -d: increase debug level (repeat to increase debug level)

        -s dir: puts the trace analysis results into directory
                tree dir (otherwise will be <file>.out)
        -N file: specify the file name which contains the
                 description of the internal networks.
                 This file must contain the subnets that will be
                 considered as 'internal' during the analysis.
                 Each subnet can be specified in one of the following types:
                 - <Network IP/NetMask> on a single line 
                     130.192.0.0/255.255.0.0
                 - <Network IP/MaskLen> on a single line 
                     130.192.0.0/16
                 - Pairs of lines with <Network IP> and <NetMask>
                     130.192.0.0
                     255.255.0.0
                 If the option is not specified all networks are
                 considered internal

        -C file: specify the file name which contains the
                 description of the cloud networks.
                 This file must contain the subnets that will be
                 considered as belonging to a specific group of networks
                 (cloud) during the analysis.
                 Subnets are specified like in the -N option.

        -H ?: print internal histograms names and definitions
        -H file: Read histogram configuration from file
                 file describes which histograms tstat should collect
                 'include histo_name' includes a single histogram
                 'include_matching string' includes all histograms
                 whose name includes the string
                 special names are:
                 'ALL' to include all histograms
                 'ADX' to include address hits histogram
                 for example, to include all TCP related
                 and the address hits histograms, file should be:
                 include ADX
                 include_matching tcp
		 'adx_mask N' is a special command to define the 
		 size of the netmask used to aggregate the address histograms
		 (e.g. 'adx_mask 24' to use the 255.255.255.0 mask)  

        -g: Enable global histo engine
        -S: No histo engine: do not create histograms files 
        -L: No log engine: do not create log_* files 
        -1: Use old (v1) log_mm format
        -B Bayes_Dir: enable Bayesian traffic classification
                      configuration files from Bayes_Dir
        -T runtime.conf: configuration file to enable/disable dumping
                         of traces and logs at runtime
        -z file: redirect all the stdout/stderr messages to the file specified
        -Z: Create gzip compressed (.gz) log files.
        -P: Create gzip compressed (.gz) pcap dump files.
        -R conf: specify the configuration file for integration with
                 RRDtool. See README.RRDtool for further information
        -r path: path to use to create/update the RRDtool database
        -l: enable live capture using libpcap
        -i interface: specifies the interface to be used to capture traffic
        -E snaplen: specifies the snaplen size used to capture traffic.
                    It might be overridden by the interface slen size
        -f filterfile: specifies the libpcap filter file. Syntax as in tcpdump

        file: trace file to be analyzed
              Use 'stdin' to read from standard input.

    Note:
        When tstat is called with no arguments (on the command line),
        it will first check if a file <tstat.conf> is provided in the
        same directory where the execution started.
        In the latter case, arguments will be read from <tstat.conf>
        rather than from the command line

    Supported Input File Formats:
        tcpdump          tcpdump format -- Public domain program from LBL
        snoop            Sun Snoop format -- Distributed with Solaris
        etherpeek        etherpeek format -- Mac sniffer program
        netmetrix        Net Metrix format -- Commercial program from HP
        ns               ns format - Network simulator ns2 from LBL
        netscout         NetScout Manager format
        erf              Endace Extensible Record format
        tcpdump live     Live capture using pcap/tcpdump library


=head2 Live Capture vs Trace Analysis


Tstat can sniff and analyze traffic on-line through the
use of either the C<libpcap> library or Endace DAG cards. 
The use of Tstat is very easy, especially if you have
experiences with C<tcpdump>, although C<tcpdump>'s knowledge
is not required to profitably use Tstat. Moreover, advanced 
users will enjoy the ability of on-line processing of traffic
captured with DAG cards.

As a minimal configuration, you must describe your network to Tstat. Indeed, in
order to distinguish forward and backward paths, Tstat needs to know which host
IP addresses can be considered as ``internal'' to the monitored network. 
There are three different format to specify the internal subnets and
if, for example, we use Politecnico di Torino subnets, which are C<130.192.0.0/16> and
C<192.204.134.0/24>, we can choose to use one of the following formats:

=over 4


=item <Network IP/MaskLen> on a single line 

    130.192.0.0/16
    192.204.134.0/16
                                                         

=item <Network IP/NetMask> on a single line 

    130.192.0.0/255.255.0.0
    192.204.134.0/255.255.0.0
                             

=item (only for backward compatibility) pairs of lines with <Network IP> and <NetMask>

    130.192.0.0
    255.255.0.0
    192.204.134.0
    255.255.0.0


=back


Note that formats can be mixed in the configuration file and comment lines
can be specified using C<'#'> so using following
configuration is still correct

    # this is a comment
    130.192.0.0/24
    192.204.134.0/255.255.0.0
    192.168.0.0
    255.255.0.0

In the directory C<tstat-conf> are placed the two files C<net.all> and
C<net.private> 

    >cat tstat-conf/net.all
    # Mask to indicate that all IP subnets are supposed to be internal
    # The same result is obtained omitting the -N option
    0.0.0.0/0.0.0.0

    >cat tstat-conf/net.private
    # Example mask to consider as internal all the subnets in the 
    # 198.168. private addresses range
    192.168.0.0/16


that can be useful for generic elaborations. In any case, if the C<-N> option
is not specified all networks are considered internal.

We can now run Tstat to capture the traffic flowing across 
our network, with the following command, which must be run as C<root> (as you
need to capture packets by putting the Ethernet interface in promiscuous mode).
The simplest command is the following:


         ./tstat -l -N net.conf


Beside live-capture, it is possible to run Tstat on a previously collected 
trace file, where the trace format can be any of the following:
	
	Supported Input File Formats:
        	tcpdump          tcpdump -- Public domain program from LBL
        	snoop            Sun Snoop -- Distributed with Solaris
        	etherpeek        etherpeek -- Mac sniffer program
        	netmetrix        Net Metrix -- Commercial program from HP
        	ns               ns -- network simulator from LBL
        	netscout         NetScout Manager format
        	erf              Endace Extensible Record Format
        	DPMI             Distributed Passive Measurement Interface (DPMI) format
	        tcpdump live     Live capture using pcap/tcpdump library

Tstat will try to read trace files given as input, and to automatically identify
the correct dump format. Trace files can be compressed or uncompressed, and
Tstat will automatically detect the compression tool used (supported formats are
C<compress, gzip, bzip2, 7z>).

Without loss of generality, we assume to use the first of the above formats. The
calling syntax is similar to the previous one, with the exception of the absence
of the live-capture switch C<-l> and the presence of the name(s) of the file(s)
that have to be processed. For example, the following command can be used to
analyze a trace file named C<LAN.dump.gz>. Results of the analysis
will be stored in a subdirectory named C<trace1>; as before, C<net.conf> contains  the
subnet description that will be considered as ``internal'' during the
analysis.


         ./tstat -s trace1 -N net.conf LAN.dump.gz


=head2 More Control


We can control the interface that we want to sniff from as well as
the output directory name as follows:


         ./tstat -i eth1 -l -s test -Nnet.conf


Moreover, we can also pipe Tstat input using the special keyword
C<stdin> as input, as in the following command (piping ns2 output to 
Tstat is left as an exercise for the reader):


         tcpdump -s 80 -i eth0 -w - ip | ./tstat -Nnet.conf -spiped stdin


In this case, Tstat is fed by C<tcpdump>'s output, and the latter has been
instructed to capture packets on the eth0 device, collecting the
first 80 bytes (to track uniquely packet headers) of IP packets only, 
and send the output to C<stdout>. Moreover, since Tstat understands 
the C<libpcap> syntax, filters can be stored in text files, as in 
the following command sequence:


         echo "vlan and ip and host 10.0.0.1" > tcpdump.conf
         ./tstat  -i eth0 -l -f tcpdump.conf -N net.conf -s filtered



=head1 Output


Tstat collects several network-layer as well as transport-layer measurements,
which are described in full details in L<http://tstat.polito.it/measure.shtml>.
As output, Tstat produces four different types of files: histograms, round robin database, 
packet level traces and other plain text logs. 

By default Tstat collect all the output results in a directory with the same name of the input 
trace appending the suffix C<.out> or C<stding> in case of a live capture:

    ./tstat -N net.conf trace1.pcap trace2.pcap # output dir: trace1.pcap.out, trace2.pcap.out
    ./tstat -N net.conf -li eth0                # output dir: generate stdin   
    ./tstat -N net.conf -s trace1 trace1.pcap   # output dir: trace1

In any case, inside the output directory is generated a subdirectory named with the
timestamp of the first packet analyzed and inside this directory the files generated
are organized as follow:

    <output_root>
    `-- 23_00_28_Jun_2008.out
        |-- 000
        |   `--- histo_logs
        |-- 001
        |   `--- histo_logs
        ...
        |-- LAST
        |   `--- histo_logs
        |
        |-- traces00
        |   `--- dump_traces
        |-- traces01
        |   `--- dump_traces
        ...
        `-- other_logs

This means that the RRD output files are not collected inside the output directory, 
in fact there is a specific command line option (-r) to indicate where this results 
have to be placed.

Recall that Tstat assumes that traces are collected on a bidirectional link,
such that both data and control packets belonging to the same flow are observed;
with the help of the figures below, we will explain the different classification
of measurements used by Tstat.


=begin text


                                   out
               +---------------------+    
               | +-----------------+ |
               | | +-+          in | |
               | | | | loc         | |
               v | v v             v |

              internal           external  
              addresses          addresses



                           s2c
               +---------------------+    
               | +-----------------+ |
               | | c2s             | |
               | |                 | |
               v |                 v |

              client              server 



=end text





=begin html


         <center><img src="tstat_output.png"/></center>


=end html



=begin latex



         \begin{figure}[!htb]
             \begin{center}
                 \includegraphics[width=0.6\textwidth]{tstat_output.eps}
             \end{center}
         \end{figure}



=end latex


Tstat identifies hosts based on their IP address. Given the description
of the internal hosts through the C<-N> command line option, Tstat
distinguishes among I<incoming>, I<outgoing> and I<local> 
measurements. Packets whose destination is an internal host and whose source is
an external host will contribute to I<incoming> measurements (red arrow in the
top figure), whereas packets going
in the opposite direction will contribute to I<outgoing> measurements (green
arrow in the top figure). Finally, in
some cases it is possible that Tstat observes packets whose source and
destination host belong to the internal host set: in such cases, measurements
will be classified as I<local> (blue arrow in the top figure).
Notice that packets whose source and destination IP
addresses belong to the external host set will be discarded.
For example, consider a setup in which Tstat is attached to a snoop port of a
LAN switch. Then Tstat will be fed by i) I<outgoing> packets going to the default gateway,
ii) I<incoming> packets coming from the default gateway, iii) I<local> packets.

Note that if you either do not know or do not want to distinguish between
internal, external and local hosts, you may enable the C<-DLOG_UNKNOWN> 
(in C<tstat/Makefile.conf> or C<libtstat/Makefile.conf>)
directive when compiling. Tstat will then be less strict, but results may
be difficult to be correctly interpreted.


Considering instead the I<role> of the host that sent the packet, statistic are
collected distinguishing between I<clients> (green arrow in the bottom figure)
and I<servers> (red arrow in the top figure), i.e., host
that opens a connection and and host that replies to connection request. Recall
that while TCP connections are well defined, UDP (and RTP/RTCP) connection
definition is more fuzzy. In this latter case, Tstat will consider as client the
source IP address of the host that sent the first packet of that flow, while the
server will be the host identified by the destination IP address of the same
packet.


Therefore, when applicable, Tstat will keep track of measurements referring to
the same measured quantity by I<appending> a specific tag (see L<"Histograms">) or using a I<flag> 
(see L<Logs>).




=head2 Logs 


=for html <a name="logs"></a>


Tstat creates a set of TXT flow files in the main output directory: C<log_tcp_complete>,
C<log_tcp_nocomplete>, C<log_udp_complete>, C<log_mm_complete>, C<log_video_complete>,
C<log_skype_complete>, C<log_chat_complete> and C<log_chat_messages>.
TCP flows can be either completed or not depending whether Tstat observed the
3-way handshaking or not; in the first case, all the measured indexes relatively
to each flow will be collected in the C<log_tcp_complete>; in the latter
case,  flows are considered as garbage and stored in C<log_tcp_nocomplete>;
Similarly, a complete log keeping track of each UDP flow measured indexes is
maintained in the C<log_udp_complete> file. Being UDP basically a
connectionless protocol, it is impossible to distinguish among C<complete> and
C<nocomplete> flows in this case.

Furthermore the following log files are created: C<log_video_complete> and
C<log_streaming_complete> for TCP video 
streaming flows (i.e. RTMP or HTTP-based video services like YouTube), 
C<log_mm_complete> for multimedia flows
(i.e. RTP, RTCP, etc), C<log_chat_complete> for IM protocols (i.e. MSN, Jabber, etc) and
C<log_skype_complete> for Skype traffic.

Description of the file format of each log file can be found in
L<http://tstat.polito.it/measure.shtml>.

If Tstat has been compiled with Zlib support, it will directly create gzip compressed 
logs (.gz) when the command line option C<-Z> is used. Internal compression might be 
CPU demanding: before enabling it, you should consider its possible effects on the Tstat 
performance.

=head2 Histograms


=for html <a name="histo"></a>


Histograms are generated periodically to generate the I<distribution> of a 
given quantity within a time interval. Tstat collects all the
measurement data during a given measurement interval defined by the C<MAX_TIME_STEP> 
parameter, which is hard-coded in the C<tstat/param.h> file to 5 minutes. Please, note
that changing the C<MAX_TIME_STEP> parameter may affect RRD creation as well.
For example, considering the IP packet length, Tstat updates, for
each observed IP packet, the counter of the number of observed packets with a
particular length. At the end of the measurement period, Tstat then saves
the values stored in the histogram in a subdirectory named with a incrementally counter
of three digits, resets all the internal values, and then restarts 
the samples collection.

To separate statistics respecting the verse (input, output or local) and the role of a
peer in the communications, is appended a tag to files generated:

=over 4

=item C<_out>

outgoing: from an internal host to an external host

=item C<_in> 

incoming: from an external host to an internal host

=item C<_loc>

local between two internal hosts 

=item C<_c2s>

going from the Client to the Server

=item C<_s2c>

going from the Server to the Client

=back

Considering the last example of previous section, we run:


         ./tstat -s trace1 -N net.conf 23_00_28_Jun_2008.dump.gz


The output generated by Tstat consists of a directory tree like the following:

        trace1
    `-- 23_00_28_Jun_2008.out
        |-- 000
        |   |-- addresses<tag>
        |   |-- flow_number<tag>
        |   |-- ip_len_in<tag>
        |    ...
        |   |-- udp_port_flow_dst<tag>
        |   `-- udp_tot_time<tag>
        |-- 001
        |   |-- addresses<tag>
        |   |-- flow_number<tag>
        |   |-- ip_len_in<tag>
        |    ...
        |   |-- udp_port_flow_dst<tag>
        |   `-- udp_tot_time<tag>
        ...
        |-- LAST
        |   |-- addresses<tag>
        |   |-- flow_number<tag>
        |   |-- ip_len_in<tag>
        |    ...
        |   |-- udp_port_flow_dst<tag>
            `-- udp_tot_time<tag>

Subdirectories with increasing numbers will be created for each measurement
period with the format C<nnn/>; histograms collecting measurement results will
be created in these directories; note that the histograms referring to the last
I<partial> time period will be stored in the LAST subdirectory. The option C<-g>
adds also the subdirectory GLOBAL containing the global histograms for the whole
measurement period.

The C<-H> has to be used to enable the histogram engine, specifying a configuration
file of C<?> to have a complete list of the available histograms. The syntax of
the configuration file is really simple:

    include ALL             # add all histograms
    include ADX             # histogram to count how many times ip address are used
    adx_mask 16             # define the size of the netmask for the ADX histogram

    include ip_len_in      # histogram of the ip packet length of the input traffic

    include_matching ip_    # match all the histograms which name start with 'ip_'
    
Histogram data are saved using simple ASCII files: 
the first line contains a description of the
measured quantity, while the second line contains the parameters of the histograms
(minimum and maximum values, and size of each bins). The list of all
the counter index and values is then dumped. To limit the file size, the
corresponding entry is omitted if the counter is zero.
For example, the histogram of the packet length C<ip_len_in> looks like:

     #IP packet length - incoming packets
     #min=0 bin_size=4 max=1600
     28 7
     36 277
     40 11760
     44 3463
     ...

Simple L<Post Processing> tools are available to automatically manage the histogram
database.


=head2 RRD


=for html <a name="rrd"></a>


The RRD output consists of a series of binary files stored in the RRD format.
Tstat forces a particular I<naming notation> of such files, which follows
the configuration rules described later in L<RRD section|"RRD Configuration">.

The RRD can then be queried with the standard RRDtool commands, such as
C<rrdcreate>, C< rrdupdate>,  C< rrdgraph>, C< rrddump>, C< rrdfetch>, 
C< rrdtune>, C< rrdlast>, C< rrdxport>, to whose manual pages we refer 
the reader for further informations.

=head2 Packet Level Traces

Inside Tstat there is a C<Deep Packet Inspector - DPI> which is able to identify
traffic communications at application level looking the composition of the payload
of packets. 

This feature is controlled by the L<Runtime module> and the output
files are placed in subdirectories named C<tracesNN> where C<NN> is an counter
incremented every time the runtime configuration is changed.
In any case, for each configuration, the input traffic in 
is splitted in traces with windows of 1 hour, that is, for example,
if we start the dump at 9:00 am

    traces00/udp_complete.pcap0       #all the udp traffic from 9:00  to 10:00
    traces00/udp_complete.pcap1       #all the udp traffic from 10:00 to 11:00
    ...

All the traces are in C<pcap> format and, because of the level 2 headers are in
general useless for statistic purpose, each packet dumped is composed of a bogus
Ethernet header (contains only zeros expect for the C<type> field which is IP)
followed by the original packet starting from IP header. The input packets
can also be truncated after a specific amount of bytes which can be configured
using the C<snap_len> specific option in the configuration file.

If Tstat has been compiled with Zlib support, it will directly create gzip compressed 
traces (.pcap.gz) when the command line option C<-P> is used. Internal compression 
of the packet traces is highly CPU demanding: before enabling it, you should consider 
its possible effects on the Tstat performance.


=head2 Post Processing


This section could be a separate HOWTO, since this
argument cannot be treated exhaustively. Perl, Awk, Ruby
I<Your-Favorite-Scripting-Language> scripts are definitively
best candidates to post-process C<log_*> files.

In the Tstat download page and in the source archive, you
can find C<plot_time.pl> and C<plot_cum.pl>, two Perl scripts that may be useful
to produce either i) time or ii) aggregated plots over different time spans.
They directly access the histogram database created by Tstat.
Please, refer to L<http://tstat.polito.it/software.php#postprocess>.

In the source code, in C<scripts/MySQL/>, you can also find a few Perl 
scripts to load the main C<log_*> files in a simple MySQL database, for further 
post-processing.

RRD files can be manipulated to obtain I<indirect> 
metrics through the RPN manipulations mechanism provided 
by RRDtool. 


=head2 Storage Considerations


To give the user a rough idea of the size of the output,
let us consider a 6 hours long, 1.6GB packet-level trace containing 
21M packets, sniffed with C<tcpdump> that was used throughout this tutorial.
Tstat identified and analyzed about 729K flows, of which about 495K were 
TCP flows, trashing 20K of them into C<log_nocomplete>.
Referring to the L<output |"Output"> above shown,
we can express the following observations:


=over 4

=item Histogram

As previously described, in order to take into account the flow directions,
several histograms are dumped for the same variable C<var_{in,out,loc,c2s,s2c}>.
Currently, about 60 measurement indexes, described in 
L<http://tstat.tlc.polito.it/measure.shtml>,  are logged, for a total
of 180 files. Each of the C<000/>, C<001/> ... C<LAST/> directories is about
500KB-1MB depending on the network traffic and on the file system block
allocation mechanism.

Therefore,  as a rule of thumb, you can count about 1MB of storage due to
histograms every 5 minutes of traffic (independently of the amount of actual
traffic load during the 5 mins...). This can be useful in order to set the
periodic dump timer to the desired trade off among time granularity versus
storage size  required.


=item RRD

The C<rrd/> directory is, per construction, of fixed size: this should not be a
surprise, since this is the goal of RRD. Therefore, the size of the database
does not depend on the amount of network traffic processed, but rather on the
RRD configuration. For the standard configuration supplied with Tstat, which is
also the one used in our Web server, the whole database occupy only 6MB and
consists of about 250 files.

=item Logs

The total size of the log files amount to about 200MB, which 
gives  a 8x reduction factor w.r.t. the packet-level trace; or,
the storage cost of each flow is about 400 bytes.

Note that the C<log_*> can be further compressed, using the C<-Z> Tstat
command line option or C<gzip> to less than 50MB, which gives a further 
4x size gain; however, for a matter of performance, is preferable 
to compress the log files I<offline>.


=back


Finally, consider that on a common PC architecture (specifically,
Intel P4 2.40GHz equipped with 2GB of RAM and 7200rpm hard-disk),
the whole trace elaboration took only 4 minutes; thus, the 
analysis rate is roughly 85Kpkts/sec or 3Kflows/sec.


=head1 RRD Module



=head2 RRDtool Installation


In order to get Tstat RRD module working, you will need to install RRDtool first
(refer to the homepage of RRDtool L<http://oss.oetiker.ch/rrdtool/>  to accomplish this step).
The autoconf file C<configure> of Tstat then should automatically add the RRD support 
if it find one (see L<Complete control of building | "Complete control of Building">).



=head2 RRD Configuration


Tstat RRD configuration is very easy, being centralized
in a single text-file, which allows to specify at runtime what measurements
should be monitored. The operating frequencies
for the RRD sampling (i.e., the parameters for the temporal 
averages) are hard-coded into C<rrdtool.h> and are chosen to 
mimic MRTG behavior. Again, take care that modifying the C<MAX_TIME_STEP>
parameter may affect the RRD management as well.

The RRD configuration file, specified through the command line option C<-R>,
should contain one line for each of the Tstat parameters that have
to be integrated into a Round Robin Database. Each line allows to
specify which statistical properties of the variable has to be tracked,
as follows:


          tstat_var1 avg min max stdev var idx:e,f,g,h,other prc:i,j,k


where C<avg,min,max,stdev,var,idx,prc,other> are keywords, whereas C<i,j,k> 
are floating point numbers and C<e,f,g,h> integer values; note that
the list of indexes (e.g., TCP ports), values (e.g., packet size)
and percentiles are comma separated. The name of the variables are
Tstat internal ones: they can be seen by executing C<./tstat -H>,
Alternatively, you can directly look into the C<000/> ...  C<LAST/>  directories or
or at L<http://tstat.polito.it/measure.shtml> 

Valid configuration lines are, e.g.:

          #
          # inspect IP packet length average, specific values and distribution
          #
          ip_len_in   avg prc:50,90,95,99 idx:40,1500,other

          #
          # TCP well known ports       
          #                       
          # 20    FTP-DATA             
          # 21    FTP                  
          # 22    SSH                  
          # 23    telnet               
          # 25    SMTP                 
          # 80    HTTP                 
          # ...                        
          #
          tcp_port_dst_in       idx:20,21,22,23,25,80,other          

          #
          # good approximation of the distribution of the RTT,
          # taking into account only the incoming path contribution
          #
          tcp_rtt_avg_in  prc:0.1,1,5,10,25,50,75,90,95,99,99.9


where, evidently, the lines starting with a C<#> sign are treated as comments.
Our Web server is currently running with the configuration
available at L<http://tstat.polito.it/download/rrd.conf>.

For each specified quantity defined in the rrd.conf file, a corresponding file
will be created.
For example, consider that the generic configuration line:


          tstat_var avg min max stdev var idx:e,f,g,h,other prc:i,j,k


will produce the following files (13 in total):


          tstat_var.{avg,min,max,stdev,var}.rrd
          tstat_var.idx{e,f,g,h,oth}.rrd
          tstat_var.prc{i,j,k}.rrd


=head2 Tstat RRD and the Web 


From the Tstat web site, you can
download the most up-to-date version of C<tstat_rrd.cgi>,
which is the CGI script that renders the Web interface.
Here is some basic tips to get it working; if you wonder
how to write your own graph templates, then you are probably
skilled enough to get it on your own C<:)>


=head3 Database Structure


The CGI scripts allow to browse on the fly the RRD database structure.
The C<rrd_data> directory is the root of the tree, where each
directory contains either i) other directories (i.e., is a box) 
or ii) a RRD-database, in which case the node is a leaf and will be
shown in the interface. In case that a directory is a plain box, it may
optionally contain some files (specifically 
{C<HEADER>,C<FOOTER>,C<README>}.{C<html>,C<txt>})
that will be rendered by C<tstat_rrd.cgi>. 
By default, the cgi script tries to load the html version;
otherwise, it tries to displays "<pre> `cat FILE` </pre>"
if such a FILE exists; finally, it will display a default message
held in $default{README} hard coded in the script.

Here is an example of the rrd_data directory which holds part of the RRD database
accessible from the Tstat web page.


        rrd_data/
         |-- Example
         |-- GARR
         |   |-- garr-live
         |   `-- garr-old
         `-- Polito
             |-- 2000
             |   |-- Apr
             |   |-- Jun
             |   |-- Jun,post155
             |   `-- May
             |-- 2001
             |   |-- Feb
             |   `-- Jan
             |-- 2005
             |   |-- Apr
             |   `-- Feb
             `-- Current
         

=head3 Web Configuration


The web configuration really depends on your web server configuration. Few
dependencies are required, most notably, the RRD Perl library from the RRDtool
installation.

It is advisable to store the Tstat RRD files
everywhere you want, and then create a symbolic link 
named C<rrd_data> that points to it (i.e., to the root of 
the RRD database tree). Similarly for the directory
where the rendered images should be stored (defaults to C<cgi-bin/rrd_images>)
and can be a symbolic link as well.
The names of these symbolic links can be redefined in the 
configuration section of C<tstat_rrd.cgi> if needed:


        #   ____________________________
        #  /                            \
        # /    configuration  __________/
        # \__________________/.:nonsns:.
        #
        # specify path to the root of the rrd database tree
        # by default, I assume there is a symbolic link in cgi-bin/
        # named rrd_data
        $RRD_DATA = 'rrd_data';

        # same thing for image directory
        # in my case, var/www/cgi-bin/rrd_images is
        # a symbolic link to "/var/www/html/rrd_images";
        # from the html browser's perspective
        $IMG_DIR = "rrd_images";


=head1 Runtime Module

This module has been developed with the specific target to try to control the disk
occupation and to have a minimal interface
to execution process to enable/disable some feature without restarting it. 
In particular, the system controls two specific outputs: the writing of log files and packet level traces, so
is possible to disable the writing of logs (histograms, RRD and all the others) if they
became to bigs, and to dynamically change the set of packet level traces to collect. 

The module works with simple polling system that is it periodically tests if a configuration file,
specified with the C<-T> option when Tstat is executed, is changed from the previous check
and in this case, the new configuration replace the previous one.

The configuration file has an C<ini> file syntax:

    > cat tstat-conf/runtime.conf
    # print logs on disk
    [log]
    histo_engine = 0    # logs created by histogram engine
    rrd_engine = 0      # logs created by rrd engine
    log_engine = 0      # all files named log_<something>

    # protocols to dump
    [dump]
    snap_len = 0        # max num of bytes to dump from ip hdr (included)
                        # 0 == all bytes
    udp_dns = 0
    udp_rtp = 0
    udp_rtcp = 0
    udp_edk = 0
    udp_kad = 0
    udp_kadu = 0        # KadU network
    udp_okad = 0        # obfuscated kad
    udp_gnutella = 0
    udp_bittorrent = 0
    udp_dc = 0
    udp_kazaa = 0
    udp_pplive = 0
    udp_sopcast = 0
    udp_tvants = 0
    udp_ppstream = 0
    udp_teredo = 0
    udp_vod = 0
    udp_unknown = 0    # all the udp traffic that the DPI doesn't recognize

    tcp_videostreaming = 0 

    ip_complete = 0    # all the ip traffic (not consider L4 type and if it's used)
    udp_complete = 0   # all the udp traffic
    tcp_complete = 0   # all the tcp traffic

    udp_maxpackets = 0
    udp_maxbytes = 0
    tcp_maxpackets = 0
    tcp_maxbytes = 0

The file in composed of the two sections C<log> and C<dump> which indicate which
type of log and dump trace to create.
Except for a few exceptions, all features are on/off type i.e. 1 and 0 values are used to 
enable/disable them. One exception is C<snap_len>, used to indicate the maximum number of bytes
dump from the input packet starting from IP level included. For example, supposing
to have a simple IP + UDP packet, using C<snap_len> = 40 it will be written a
packet of 54 bytes

    14 (bogus ethernet) + 20 (IP) + 8 (UDP) + 12 (payload)

For UDP traffic it can be specified a set of applications so to have a specific
dump trace for each application of interest. The unknown traffic i.e. the traffic
that the Tstat's DPI is not able to identify, is placed in a separated trace.
For example, using the following configuration

    udp_rtp = 1
    udp_edk = 1
    udp_bittorrent = 1
    udp_unknown = 1    

it's expected to have 4 traces i.e. three protocols/applications (RTP, eMule, Bittorrent)
and the unknown (for example DNS traffic).

Classified TCP complete flows cannot be "safely" dumped, since classification
happens after the 3-way handshaking finished, so saved flows would be
incomplete. 
C<tcp_videostreaming> is an exception, used to dump TCP flows that were classified
as video through the Streaming DPI engine (the ones logged in
C<log_streaming_complete>), even if the 3-way handshaking and the first flow payload
packets would be skipped. This could be activated if you're interested in performing
a secondary analysis on characteristics of the video stream.

Beside the traces at application level, it's possible to create three type of aggregated
traces. In particular, C<udp_complete> is all the UDP traffic (both applications specific and unknown),
C<tcp_complete> is all the TCP traffic, while
C<ip_complete> refers to all the traffic that use IP as level 3 without considering the level 4. 
In other words, C<ip_complete> is the aggregation of TCP, UDP and all the other network protocols that use directly IP
(ICMP, IPIP, ESP, ...). The three options are NOT to complementary so
it's possible to enable all of them contemporary but this obviously means that a TCP/UDP packet
it will appear in more than one trace so particular attention should be taken.

When dumping all TCP (C<tcp_complete>) or UDP (C<udp_complete>) traffic, 
it is possible to limit the dumping of each
flow to either a maximum number of packets or a maximum number of bytes trasferred.
For example, to save just the first 30000 bytes or the first 30 segments of
each TCP flow (whichever condition if reached first), you can use
 
    snap_len = 0
    tcp_complete = 1
    tcp_maxpackets = 30
    tcp_maxbytes = 30000

C<udp_maxpackets> and C<udp_maxbytes> provide the same functionality for UDP flows.
If both C<xxx_maxpackets> and C<xxx_maxbytes> are set to 0, the complete TCP/UDP 
flows will be saved, with no size limitation.

During the runtime execution of Tstat, the configuration file is controlled periodically
looking for changes in the options. In this way, when Tstat is used for online monitoring, 
is possible to interact with the dumping module without the need to restart the program. 
When a change is identified a new C<tracesNN> output directory is created
in the root output directory to collect all the new traces 
and is also generated a file called C<log.txt> that indicate the dump configuration 
used for that particular dump.




=head1 DPMI Module


To the experienced DPMI user, it can turn very useful to
think of Tstat in terms of a DPMI consumer, thus suitable
for live usage. Basically, two configuration files need to 
be provided in this case.


=head2 Tstat Configuration for DPMI

Especially for this purpose,  Tstat can be executed without any argument
on the command line, provided that a file named C<tstat.conf> 
exists in the same path where the C<tstat> command has been
executed. Note that the filename MUST be in this case C<tstat.conf> 


In the latter case, arguments will be read from 
C<tstat.conf> rather than from the command line, which makes
Web-based execution easier -- it just requires the creation of
a text file.

Typically, the content of the file will be one of the two following
cases. When only the RRD module need to be turned on, which is 
specially suitable for the persistent monitoring of a network link:

	  -D dpmi.conf -S -R rrd.conf -r data.rrd

Or, in the case where more detailed transport layer logs and histograms 
are to be generated, such as for shorter ad-hoc experiment:

	  -D dpmi.conf -s data

Note that the C<dpmi.conf> filename, which is the object of the next 
section, is customizable.


=head2 DPMI Configuration for Tstat


This file is used by Tstat in order to properly set-up the 
DPMI library and, possibly, its filters. There are only two
keywords that are interpreted by Tstat, and I<the whole> 
content of this file is passed to the DPMI's C<createfiler>
library call.
Tstat-keywords are prepended by the C<tstat:> prefix, to 
solve any ambiguity, and are related to the type of stream
and measurement direction.
More specifically, 

=over 4


=item C<tstat:(file|(tcp|udp|eth)[:port])>


Specify whether a tracefile or a network socket (and in this case, which port)
is the source of DPMI traffic. Note that in the case where a tracefile
is used, there is no real need to specify this, since the format recognition
happens automatically; thus, the C<tstat:file> keyword is provided for completeness.
Conversely, options such as C<tstat:eth> and C<tstat:tcp:32449> are
necessary in order for network sockets to properly be setup.


=item C<tstat:MP:CI>


This option is used to define the traffic directionality, specifying 
what network card interface (CI) and the measurement point (MP) 
are related to I<incoming> traffic from external sources.
Referring to the DPMI library internals:
      
      CI <-> char nic[8];     
      MP <-> char mampid[8];  

=back


In order to provide a safe fallback or a missing configuration,
unless otherwise specified, the first received frame is assumed to 
be ``incoming'', thus arbitrarily determining the incoming CI:MP 
couple.



=head1 Bayesian Classification of Skype Traffic

The Bayesian framework is configured through a directory (C<-B> command line option)
containing several configuration files. A example of configuration
is provided under the C<tstat-conf> directory so please refer to this directory
reading this explanation. In the configuration directory 
two files have to be placed, named C<pktsize.conf> and C<avgipg.conf> which define
the parameters used by the classification framework to describe the
B<packet size> and B<average inter-packet gap>.

Both files have the same format specified in the example below:

       #   ____________________________  
       #  /                   \ 
       # /    BayesConf      __________/ 
       # \__________________/.:nonsns:.  
       #                   
       #===============================================
       # feature name
       #-----------------------------------------------
       # Known Skype features:
       #       PKTSIZE 
       #       AVGIPG
       #
       FEATURE    AVGIPG
       #
       #===============================================
       # default flags 
       #-----------------------------------------------
       # USE_LOG        1
       # NORMALIZE      1
       # AUTO_OTHER     0
       #
       WINDOW_SIZE      1
       CLASS_LEN        250
       MIN_THRESHOLD    1e-25
       AVG_THRESHOLD   -3.5
       WIN_THRESHOLD   -3
       #
       #===============================================
       # class definition
       #-----------------------------------------------
       # syntax
       #     DISCRETE  class P{class}
       #     GAUSSIAN  class P{class} mu sigma
       #     GAUSSIAN+ class P{class} N (w1,m1,s1) .. (wN,mN,sN)
       #
       # note: P{class} may be "="
       #
       GAUSSIAN mode1 = 10 2
       GAUSSIAN mode2 = 20 2
       GAUSSIAN mode3 = 30 2
       GAUSSIAN mode4 = 40 2
       GAUSSIAN mode5 = 50 2
       GAUSSIAN mode6 = 60 2
       

The keyword C<FEATURE> is used to specify which type of statistic the configuration
file is refered to. In the example above we are dealing with the average inter-packet gap,
and specifying C<PKTSIZE> we will describe packet size feature.

Each feature then has a set of flags and other options values that can be 
used to change the configuration of the NBC engine. Default parameter are strongly suggested, but in case
you want to experiment with different combinations, you can try to change them.

=over 4

=item C<USE_LOG>:

If set to 1, the function log10() is applied to the probability values 
instead to use the actual probability value; this avoids eventual underflow errors when dealing 
with very low probabilities.


=item C<NORMALIZE>:

If set to 1, the beliefs computed are re-normalized in the range 0:1;
this option is valid only if USE_LOG is disabled (by default is enabled);

=item C<WINDOW_SIZE>:

The number of packets after which recompute beliefs (by default after each packet);

=item C<CLASS_LEN>:

The maximum value assumed by the feature and is used to compute class probability
distribution functions (by default is 0);

=item C<MIN_THRESHOLD>:

A positive small value that replace the value 0 in the computation of beliefs
to avoid underflows because of logarithm function (by default 1e-33);

=item C<AVG_THRESHOLD>:

The static threshold used to compare the maximum computed belief and take the classification.

=item C<WIN_THRESHOLD>:

A static threshold is used to count the number of individual samples (rather than
their mean) that passes a more restrictive test (indeed the window threshold
is greater than the average threshold).

=back

Important configuration parameters are the ``modes'' which must be carefully defined. Modes are 
the set of p.d.f. that describe the expected distribution of the feature.

Modes may be described as a C<DISCRETE> function, that is a generic distributions, 
or as a C<GAUSSIAN> function, that is a gaussian (or a superposition of a gaussian) distribution. 

Each mode then is associated with a name and a probability which is used as a weight.
If C<'='> is used instead of a weight specific values, all weight are assumed to be uniform.

The special type C<GAUSSIAN+> may be used to define a mode composed of C<N> 
different gaussian distributions. Each function is defined by mean and standard deviaton sigma
and the weight of the mixture have to be specified.

Assuming that you have configured both average ipg and packet size feature 
in a directory named C<bayes_conf_dir> the classification engine can be 
enabled simply specifying the C<-B> command line option:

    # using live capture mode
	./tstat -l -B <bayes_conf_dir> -N net.conf

    # using a packet dump trace
	./tstat -B <bayes_conf_dir> -N net.conf tracefile.dump


=head1 Libtstat library

Libtstat is a shared library that can be used by external programs to access to
the statistics and classification features provided by Tstat. 
As described in the Install section of this document, to enable the building of
Libtstat library is needed to provide a configure option

    ./configure --enable-libtstat

=head2 Link the Libtstat library

When the library is installed in the system using C<make install> the
following messages are printed on the console

    ----------------------------------------------------------------------
    Libraries have been installed in:
    /usr/local/lib

    If you ever happen to want to link against installed libraries
    in a given directory, LIBDIR, you must either use libtool, and
    specify the full pathname of the library, or use the `-LLIBDIR'
    flag during linking and do at least one of the following:
    - add LIBDIR to the `LD_LIBRARY_PATH' environment variable
      during execution
    - add LIBDIR to the `LD_RUN_PATH' environment variable
      during linking
    - use the `-Wl,--rpath -Wl,LIBDIR' linker flag
    - have your system administrator add LIBDIR to `/etc/ld.so.conf'

    See any operating system documentation about shared libraries for
    more information, such as the ld(1) and ld.so(8) manual pages.
    ----------------------------------------------------------------------

This indicate where the library has been installed and how to
link that to some program. The most simple thing to do, is to 
use the native libtool support for automake, that is, assuming
that C<program_name> is the name of the executable of the tool
to generate, it is needed to add the following lines to C<Makefile.am>
of the tool:

    program_name_LDADD = -ltstat -lpcap -lpthread -lm
    program_name_LDFLAGS = -Wl,--rpath -Wl,<libtstat_dir>

This allow a fined control on the directory where the library 
has been installed. Anyway, if it has been installed in a
standard library location (as C</usr/lib>), instead of the previous
lines, it can be added 

    AC_CHECK_LIB([tstat], [tstat_next_pckt],, AC_MSG_ERROR([missing 'tstat' library]))

in C<configure.ac> of the current project. This automatically
look for the presence of a function tstat_next_pckt() in a system library
named C<libtstat>. In case of error of error print a message stopping the
configuration process, instead in case of success, are automatically added
all the linking options needed to build the program (see the autotools 
files in C<libtstat-demo> for a complete example).


=head2 Libtstat API

Tstat's elaborations are perfomed starting from the level 3 (IP) so
its is input is a simple array of bytes that contains a packet
starting from level 3. This means is the external program that
has to open a trace or read a packet from a network card and to
parse all the level 2 headers just to have a pointer to the IP header.
From this point of view, it can be said that Tstat is simply a wrapper
around Libtstat that add only the support to parse a set of level 2
headers.


=over 1

=item int tstat_init (char *config_fname)

C<config_fname> is a file name containing a set of Tstat options, one 
for each line

    >cat tstat-conf/tstat.conf
    #-s outdir      # output directory
    -N net.all      # network config file 
    #-B bayesdir    # directory of the bayes config files
    #-d             # debug


If NULL is provided, the library use C<./tstat.conf> as filename.

=item void tstat_new_logdir (char *filename, struct timeval *pckt_time)

This function has to be called before the process of the first packet
and allow to generate the output directory using this hierarchy:

    <filename>.out
        |__<pckt_time>.out


=item int tstat_next_pckt (struct timeval *pckt_time, void *ip_hdr, void *last_ip_byte, int tlen, ip_direction)

This function enable the processing of a new packet.
C<pckt_time>  is the timestamp of the packet, C<ip_hdr> is a pointer to the first ip byte,
C<last_ip_byte> is a pointer to the last ip byte, and C<tlen> is the number of total bytes (captured).
Instead C<ip_direction> indicates if the packet is incoming or outgoing. Possible values :

=over 2

=item 

0: use the address based classification provided by the -N option

=item 

1: packet is treated as having internal source and internal destination (local packet)

=item 

2: packet is treated as having internal source and external destination (outgoing packet) 	     

=item

3: packet is treated as having external source and internal destination (incoming packet)

=item

4: packet is treated as having external source and external destination (external packet, will be ignored)

=back
            

=item tstat_report *tstat_close (tstat_report *report)

This function flush to file all the pending statistics
and fill a tstat_report structure with some general
results.

=item void tstat_print_report (tstat_report *report, FILE *file)

This function print a formatted report to file
using tstat_report data.

=back

=head1 Author Informations

=over 4

=item Active authors:


    Maurizio Munafo'    <munafo@polito.it>
    Alessandro Finamore <finamore@mail.tlc.polito.it>

=item Other active authors:


    Marco Mellia <mellia@mail.tlc.polito.it>
    Dario Rossi  <dario.rossi@enst.fr> 
    Vinicius Gehleb <vinicius@gehlen.us>

=item Other authors:


    Andrea Carpani, Luca Muscariello, Dario Bonfiglio, Robert Birke

=item Other links:

    Telecommunication Networks Group (TNG)
    DELEN, Politecnico di Torino
    http://www.tlc-networks.polito.it

=back


=head1 Acknowledgment

Many people contributed to the development of Tstat. Tstat would never have seen
the light had not C<TCPTrace> being invented.
Many thanks to Shawn Ostermann and to the  Ohio
University for their great program.

Many Master and PhD students took part in the development and debugging of
Tstat. Naming all of them would be impossible. We would then like to thank Luca
Muscariello for the entropy generated in the TCP
anomalies identification, and Prof. Marco Ajmone Marsan and 
Prof. Fabio Neri who gave us the moral and scientific support to 
continue investing in Tstat.



=head1 License



Copyright (c) 2001-2012 Politecnico di Torino.  All rights reserved.

 
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.


=cut
