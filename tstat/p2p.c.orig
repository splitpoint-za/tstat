/*
 *
 * Copyright (c) 2001
 *	Politecnico di Torino.  All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Author:	Marco Mellia, Andrea Carpani, Luca Muscariello, Dario Rossi
 * 		Telecomunication Networks Group
 * 		Politecnico di Torino
 * 		Torino, Italy
 *              http://www.tlc-networks.polito.it/index.html
 *		mellia@mail.tlc.polito.it, rossi@mail.tlc.polito.it
 *
 * Tstat is deeply based on TCPTRACE. The authors would like to thank
 * Shawn Ostermann for the development of TCPTRACE.
 *
*/

#include <stdio.h>
#include <assert.h>

#include "tstat.h"
#include "tcpL7.h"

#define P2P_DEBUG_LEVEL 1
#define P2P_DEBUG (debug>=P2P_DEBUG_LEVEL)
extern int debug;
extern Bool log_engine;
extern FILE *fp_udp_logc;

int UDP_p2p_to_L7type (ucb * thisflow);

void
p2p_init ()
{
  /* nothing to do so far */
}

void *
getp2p (struct udphdr *pudp, int tproto, void *pdir, void *plast)
{
  /* just pass the complete packet and let the p2p_flow_stat decide */

  return (void *) pudp;
}

void
p2p_flow_stat (struct ip *pip, void *pproto, int tproto, void *pdir,
	       int dir, void *hdr, void *plast)
{
  int return_code;
  tcp_pair *ptp;
  ucb *udir;

  if (tproto == PROTOCOL_UDP)
    {

      udir = (ucb *) pdir;

#ifndef P2P_DETAILS
      if (udir->type != UDP_UNKNOWN)
	return;
#endif

      return_code =
	p2p_udp_match (pip, pproto, tproto, pdir, dir, hdr, plast);

      if (return_code != 0)
	{
#ifdef P2P_DETAILS
	  udir->is_p2p = 1;
	  (udir->p2p).total_pkt++;
#endif

	  switch (return_code / 100)
	    {
	    case IPP2P_EDK:
	      udir->type = P2P_EDK;
	      break;
	    case IPP2P_KAD:
	      udir->type = P2P_KAD;
	      break;
	    case IPP2P_KADU:
	      udir->type = P2P_KADU;
	      break;
	    case IPP2P_GNU:
	      udir->type = P2P_GNU;
	      break;
	    case IPP2P_BIT:
	      udir->type = P2P_BT;
	      break;
	    case IPP2P_DC:
	      udir->type = P2P_DC;
	      break;
	    case IPP2P_KAZAA:
	      udir->type = P2P_KAZAA;
	      break;
	    case IPP2P_JOOST:
	      /* add bayes engine */
	      udir->type = P2P_JOOST; 
	      break; 
	    case IPP2P_PPLIVE:
	      udir->type = P2P_PPLIVE;
	      break;
	    case IPP2P_SOPCAST:
	      udir->type = P2P_SOPCAST;
	      break;  
	    case IPP2P_TVANTS:
	      udir->type = P2P_TVANTS;
	      break;  
	    }

#ifdef P2P_DETAILS
	  switch (return_code / 100)
	    {
	    case IPP2P_EDK:
	      (udir->p2p).pkt_type_num[0]++;
	      break;
	    case IPP2P_KAD:
	      (udir->p2p).pkt_type_num[1]++;
	      break;
	    case IPP2P_KADU:
	      (udir->p2p).pkt_type_num[2]++;
	      break;
	    case IPP2P_GNU:
	      (udir->p2p).pkt_type_num[3]++;
	      break;
	    case IPP2P_BIT:
	      (udir->p2p).pkt_type_num[4]++;
	      break;
	    case IPP2P_DC:
	      (udir->p2p).pkt_type_num[5]++;
	      break;
	    case IPP2P_KAZAA:
	      (udir->p2p).pkt_type_num[6]++;
	      break;
	    }
#endif
	}

    }
  else
    {

      tcphdr *ptcp;
      ptcp = (tcphdr *) hdr;

      ptp = ((tcb *) pdir)->ptp;
      if (ptp != NULL && ptp->p2p_state != IGNORE_FURTHER_PACKETS2)
	{
	  return_code =
	    p2p_tcp_match (pip, pproto, tproto, pdir, dir, hdr, plast);
	  if (return_code != 0)
	    {
	      /* this flow is a P2P flow, so the L7 FLOW must be set */

	      ptp->con_type |= P2P_PROTOCOL;

	      if (ptp->p2p_type != 0
		  && (ptp->p2p_type / 100) != (return_code / 100))
		{
		  printf
		    ("Warning: multiple P2P type matching: Old %d - New %d\n",
		     ptp->p2p_type, return_code);
		}
	      else if (ptp->p2p_type != 0 && ptp->p2p_type != return_code)
		{
		  //    printf("Warning: multiple P2P commands matching: Old %d - New %d\n",ptp->p2p_type,return_code);
		}
	      else
		ptp->p2p_type = return_code;
	    }
	  if (ptp->packets > MAX_PACKETS_CON)
	    ptp->p2p_state = IGNORE_FURTHER_PACKETS2;
	}
    }


}

int
p2p_tcp_match (struct ip *pip, void *pproto, int tproto, void *pdir,
	       int dir, void *hdr, void *plast)
{
  extern struct tcpmatch matchlist[];
  int payload_len;
  tcphdr *ptcp;
  unsigned char *haystack;
  int data_len;
  int p2p_result;
  int i;


  ptcp = (tcphdr *) hdr;
  i = 0;

  payload_len =
    getpayloadlength (pip, plast) - ((tcphdr *) pproto)->th_off * 4;

  haystack = (unsigned char *) ptcp + ptcp->th_off * 4;
  data_len = (unsigned char *) plast - (unsigned char *) haystack + 1;

  if (data_len <= 0 || payload_len == 0)
    return 0;


  p2p_result = 0;
  while (matchlist[i].command)
    {
      if (payload_len > matchlist[i].packet_len)
	{
	  p2p_result =
	    matchlist[i].function_name (haystack, payload_len, data_len);
	  if (p2p_result)
	    {
	      /*
	         if (info->debug) printk("IPP2P.debug:TCP-match: %i from: %u.%u.%u.%u:%i to: %u.%u.%u.%u:%i Length: %i\n", 
	         p2p_result, NIPQUAD(ip->saddr),ntohs(tcph->source), NIPQUAD(ip->daddr),ntohs(tcph->dest),hlen);
	       */
	      return p2p_result;
	    }
	}
      i++;
    }
  return p2p_result;
}

int
p2p_udp_match (struct ip *pip, void *pproto, int tproto, void *pdir,
	       int dir, void *hdr, void *plast)
{
  extern struct udpmatch udp_list[];
  int payload_len;
  udphdr *pudp;
  unsigned char *haystack;
  int p2p_result;
  int data_len;
  int i;


  pudp = (udphdr *) hdr;
  payload_len = ntohs (((struct udphdr *) pproto)->uh_ulen);
  /* This is the UDP complete length, included the header size */

  i = 0;

  haystack = (unsigned char *) pudp;
  data_len = (unsigned char *) plast - (unsigned char *) haystack + 1;

  p2p_result = 0;
  while (udp_list[i].command)
    {
      if (payload_len > udp_list[i].packet_len)
	{
	  p2p_result = udp_list[i].function_name (haystack, payload_len, data_len);
	  if (p2p_result)
	    {
	      /*
	         if (info->debug) printk("IPP2P.debug:UDP-match: %i from: %u.%u.%u.%u:%i to: %u.%u.%u.%u:%i Length: %i\n", 
	         p2p_result, NIPQUAD(ip->saddr),ntohs(udph->source), NIPQUAD(ip->daddr),ntohs(udph->dest),hlen);
	       */
	      return p2p_result;
	    }
	}
      i++;
    }
  return p2p_result;
}


/* this will be called by the plugin */
void
make_p2p_conn_stats (void *flow, int tproto)
{
  ucb *thisUdir, *thisC2S, *thisS2C;
  char logline[500];
  udp_pair *pup;
  udp_pair *thisflow = (udp_pair *) flow;

  if (tproto == PROTOCOL_TCP)
    return;

  thisC2S = &(thisflow->c2s);
  thisS2C = &(thisflow->s2c);
    
  /* log only P2P or unknown traffic. avoid RTP and SKYPE that are managed
     by their plugin */
  if ((thisC2S->type < RTP || thisC2S->type >= P2P_EDK) &&
      (thisS2C->type < RTP || thisS2C->type >= P2P_EDK))
    {
      int L7type = UDP_p2p_to_L7type (thisC2S);

      switch (in_out_loc
	      (thisflow->internal_src, thisflow->internal_dst, C2S))
	{
	case OUT_FLOW:
	  add_histo (L7_UDP_num_out, L7type);
	  break;
	case IN_FLOW:
	  add_histo (L7_UDP_num_in, L7type);
	  break;
	case LOC_FLOW:
	  add_histo (L7_UDP_num_loc, L7type);
	  break;
	}

      L7type = UDP_p2p_to_L7type (thisS2C);

      switch (in_out_loc
	      (thisflow->internal_src, thisflow->internal_dst, S2C))
	{
	case OUT_FLOW:
	  add_histo (L7_UDP_num_out, L7type);
	  break;
	case IN_FLOW:
	  add_histo (L7_UDP_num_in, L7type);
	  break;
	case LOC_FLOW:
	  add_histo (L7_UDP_num_loc, L7type);
	  break;
	}
    }
#ifndef LOG_ALL_UDP
  else
    return;
#endif

  if (!log_engine || fp_udp_logc == NULL)
    return;

  thisUdir = thisC2S;
  pup = thisUdir->pup;

  //     #   Field Meaning
  //    --------------------------------------
  //     1   Source Address
  //     2   Source Port

  sprintf (logline, "%s %s",
	   HostName (pup->addr_pair.a_address),
	   ServiceName (pup->addr_pair.a_port));

  //     3   Flow Start Time
  //     4   Flow Elapsed Time [s]
  //     5   Flow Size [Bytes]
  sprintf (logline,
	   "%s %f %.6f %llu",
	   logline,
	   1e-6 * time2double ((thisUdir->first_pkt_time)),
	   elapsed (thisUdir->first_pkt_time, thisUdir->last_pkt_time) /
	   1000.0 / 1000.0, thisUdir->data_bytes);

  //     6   No. of Total flow packets
  sprintf (logline, "%s %lld", logline, thisUdir->packets);

  // 7 internal address
  // 8 udp_type

  sprintf (logline, "%s %d %d",
	   logline, thisflow->internal_src, thisUdir->type);

#ifdef P2P_DETAILS
  sprintf (logline, "%s %d %d %d %d %d %d",
	   //  9
	   //  10 Emule-EDK
	   //  11 Emule-KAD
	   //  12 Emule-KADU
	   //  13 Gnutella
	   //  14 Bittorrent
	   //  15 DirectConnect
	   //  16 Kazaa
	   logline, thisUdir->p2p.total_pkt,
	   thisUdir->p2p.pkt_type_num[0],
	   thisUdir->p2p.pkt_type_num[1],
	   thisUdir->p2p.pkt_type_num[2],
	   thisUdir->p2p.pkt_type_num[3],
	   thisUdir->p2p.pkt_type_num[4],
	   thisUdir->p2p.pkt_type_num[5], thisUdir->p2p.pkt_type_num[6]);
#endif

  thisUdir = thisS2C;
  pup = thisUdir->pup;

  //     #   Field Meaning
  //    --------------------------------------
  //     9   Source Address
  //     10   Source Port

  sprintf (logline, "%s %s %s",
	   logline,
	   HostName (pup->addr_pair.b_address),
	   ServiceName (pup->addr_pair.b_port));

  //     11   Flow Start Time
  //     12   Flow Elapsed Time [s]
  //     13   Flow Size [Bytes]
  sprintf (logline,
	   "%s %f %.6f %llu",
	   logline,
	   1e-6 * time2double ((thisUdir->first_pkt_time)),
	   elapsed (thisUdir->first_pkt_time, thisUdir->last_pkt_time) /
	   1000.0 / 1000.0, thisUdir->data_bytes);

  //     14   No. of Total flow packets
  sprintf (logline, "%s %lld", logline, thisUdir->packets);

  // 15 internal address
  // 16 udp_type

  sprintf (logline, "%s %d %d",
	   logline, thisflow->internal_dst, thisUdir->type);

#ifdef P2P_DETAILS
  sprintf (logline, "%s %d %d %d %d %d %d",
	   //  9
	   //  10 Emule-EDK
	   //  11 Emule-KAD
	   //  12 Emule-KADU
	   //  13 Gnutella
	   //  14 Bittorrent
	   //  15 DirectConnect
	   //  16 Kazaa
	   logline, thisUdir->p2p.total_pkt,
	   thisUdir->p2p.pkt_type_num[0],
	   thisUdir->p2p.pkt_type_num[1],
	   thisUdir->p2p.pkt_type_num[2],
	   thisUdir->p2p.pkt_type_num[3],
	   thisUdir->p2p.pkt_type_num[4],
	   thisUdir->p2p.pkt_type_num[5], thisUdir->p2p.pkt_type_num[6]);
#endif

  fprintf (fp_udp_logc, "%s\n", logline);

  return;
}

int
UDP_p2p_to_L7type (ucb * thisflow)
{
  switch (thisflow->type)
    {
    case RTP:
    case RTCP:
    case SKYPE_E2E:
    case SKYPE_E2E_BAYES:
    case SKYPE_E2E_CHI:
    case SKYPE_E2E_BAYES_CHI:
    case SKYPE_OUT:
    case SKYPE_OUT_BAYES:
    case SKYPE_OUT_CHI:
    case SKYPE_OUT_BAYES_CHI:
    case SKYPE_SIG:
    case SKYPE_BAYES_CHI:
    case SKYPE_BAYES:
    case SKYPE_CHI:
    default:
      printf ("ERROR: UDP_p2p_to_L7type cannot classify here!!!");
      exit (1);

    case P2P_EDK:
      return L7_FLOW_EDK;

    case P2P_KAD:
      return L7_FLOW_KAD;

    case P2P_KADU:
      return L7_FLOW_KADU;

    case P2P_DC:
      return L7_FLOW_DC;

    case P2P_GNU:
      return L7_FLOW_GNU;

    case P2P_KAZAA:
      return L7_FLOW_KAZAA;

    case P2P_BT:
      return L7_FLOW_BIT;

    case P2P_JOOST:
      return L7_FLOW_JOOST;

    case P2P_PPLIVE:
      return L7_FLOW_PPLIVE;
      
    case P2P_SOPCAST:
      return L7_FLOW_SOPCAST; 
    
    case P2P_TVANTS:
      return L7_FLOW_TVANTS; 

    case UDP_UNKNOWN:
    case FIRST_RTP:
    case FIRST_RTCP:
      return L7_FLOW_UNKNOWN;
    }
}



int
TCP_p2p_to_L7type (tcp_pair * thisflow)
{
  switch (thisflow->p2p_type / 100)
    {
    case IPP2P_EDK:
    case IPP2P_DATA_EDK:
      return L7_FLOW_EDK;

    case IPP2P_KAZAA:
    case IPP2P_DATA_KAZAA:
      return L7_FLOW_KAZAA;

    case IPP2P_DATA_DC:
    case IPP2P_DC:
      return L7_FLOW_DC;

    case IPP2P_DATA_GNU:
    case IPP2P_GNU:
      return L7_FLOW_GNU;

    case IPP2P_BIT:
      return L7_FLOW_BIT;

    case IPP2P_APPLE:
      return L7_FLOW_APPLE;

    case IPP2P_SOUL:
      return L7_FLOW_SOUL;

    case IPP2P_WINMX:
      return L7_FLOW_WINMX;

    case IPP2P_ARES:
      return L7_FLOW_ARES;

    case IPP2P_MUTE:
      return L7_FLOW_MUTE;

    case IPP2P_WASTE:
      return L7_FLOW_WASTE;

    case IPP2P_XDCC:
      return L7_FLOW_XDCC;
    }
  return L7_FLOW_UNKNOWN;
}

